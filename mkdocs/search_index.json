{
    "docs": [
        {
            "location": "/", 
            "text": "zend-dom\n\n\n\n\n\n\nThe \nZend\\Dom\n component provides tools for working with DOM documents and\nstructures. Currently, we offer \nZend\\Dom\\Query\n, which provides a unified\ninterface for querying DOM documents utilizing both XPath and CSS selectors.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-dom/issues\n\n\nDocumentation is at http://framework.zend.com/manual/current/en/index.html#zend-dom", 
            "title": "Home"
        }, 
        {
            "location": "/#zend-dom", 
            "text": "The  Zend\\Dom  component provides tools for working with DOM documents and\nstructures. Currently, we offer  Zend\\Dom\\Query , which provides a unified\ninterface for querying DOM documents utilizing both XPath and CSS selectors.   File issues at https://github.com/zendframework/zend-dom/issues  Documentation is at http://framework.zend.com/manual/current/en/index.html#zend-dom", 
            "title": "zend-dom"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-dom provides tools for working with DOM documents and structures.\nCurrently, we offer \nZend\\Dom\\Query\n, which provides a unified interface for\nquerying DOM documents utilizing both XPath and CSS selectors.", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-dom provides tools for working with DOM documents and structures.\nCurrently, we offer  Zend\\Dom\\Query , which provides a unified interface for\nquerying DOM documents utilizing both XPath and CSS selectors.", 
            "title": "Introduction"
        }, 
        {
            "location": "/query/", 
            "text": "Querying HTML and XML Documents\n\n\nZend\\Dom\\Query\n provides mechanisms for querying XML and HTML documents\nutilizing either XPath or CSS selectors. It was developed to aid with functional\ntesting of MVC applications, but could also be used for development of screen\nscrapers.\n\n\nCSS selector notation is provided as a simpler and more familiar notation for\nweb developers to utilize when querying documents with XML structures. The\nnotation should be familiar to anybody who has developed Cascading Style Sheets\nor who utilizes javascript toolkits that provide functionality for selecting\nnodes utilizing CSS selectors.  \nPrototype's $$()\n,\n\nDojo's dojo.query\n, and\n\njQuery\n were all inspirations for the component.\n\n\nTheory of Operation\n\n\nTo use \nZend\\Dom\\Query\n, you instantiate a \nZend\\Dom\\Query\n object, optionally\npassing a document to query (a string). Once you have a document, you can use\neither the \nexecute()\n or \nqueryXpath()\n methods; each method will return a\n\nZend\\Dom\\NodeList\n object with any matching nodes.\n\n\nThe primary difference between \nZend\\Dom\\Query\n and using\n\nDOMDocument\n + \nDOMXPath\n\nis the ability to select against CSS + selectors. You can utilize any of the\nfollowing, in any combination:\n\n\n\n\nelement types\n: provide an element type to match: \ndiv\n, \na\n, \nspan\n, \nh2\n, etc.\n\n\nstyle attributes\n: CSS style attributes to match: \n.error\n, \ndiv.error\n,\n  \nlabel.required\n, etc. If an element defines more than one style, this will\n  match as long as the named style is present anywhere in the style declaration.\n\n\nid attributes\n: element ID attributes to match: \n#content\n, \ndiv#nav\n, etc.\n\n\narbitrary attributes\n: arbitrary element attributes to match. Three\n  different types of matching are provided:\n\n\nexact match\n: the attribute \nexactly\n matches the specified string.\n  \ndiv[bar=\"baz\"]\n would match a \ndiv\n element with a \nbar\n attribute that\n  exactly matches the value \nbaz\n.\n\n\nword match\n: the attribute contains a \nword\n matching the string.\n  \ndiv[bar~=\"baz\"]\n would match a \ndiv\n element with a \nbar\n attribute that\n  contains the word \nbaz\n. \ndiv bar=\"foo baz\"\n would match, but\n  \ndiv bar=\"foo bazbat\"\n would not.\n\n\nsubstring match\n: the attribute contains the string specified, whether or\n  not it is a complete word. \ndiv[bar*=\"baz\"]\n would match a \ndiv\n element\n  with a \nbar\n attribute that contains the string \nbaz\n anywhere within it.\n\n\n\n\n\n\ndirect descendents\n: utilize \n between selectors to denote direct\n  descendents. \ndiv \n span\n would select only \nspan\n elements that are direct\n  descendents of a \ndiv\n. Can also be used with any of the selectors above.\n\n\n\n\ndescendents\n: string together multiple selectors to indicate a hierarchy along which to search.\n  \ndiv .foo span #one\n would select an element of id \none\n that is a descendent\n  of arbitrary depth beneath a \nspan\n element, which is in turn a descendent of\n  arbitrary depth beneath an element with a class of \nfoo\n, that is an\n  descendent of arbitrary depth beneath a \ndiv\n element. For example, it would\n  match the link to the word 'One' in the listing below:\n\n\ndiv\n\n\ntable\n\n    \ntr\n\n        \ntd class=\nfoo\n\n            \ndiv\n\n                Lorem ipsum \nspan class=\nbar\n\n                    \na href=\n/foo/bar\n id=\none\nOne\n/a\n\n                    \na href=\n/foo/baz\n id=\ntwo\nTwo\n/a\n\n                    \na href=\n/foo/bat\n id=\nthree\nThree\n/a\n\n                    \na href=\n/foo/bla\n id=\nfour\nFour\n/a\n\n                \n/span\n\n            \n/div\n\n        \n/td\n\n    \n/tr\n\n\n/table\n\n\n/div\n\n\n\n\n\n\n\n\nOnce you've performed your query, you can then work with the result object to\ndetermine information about the nodes, as well as to pull them and/or their\ncontent directly for examination and manipulation. \nZend\\Dom\\NodeList\n\nimplements \nCountable\n and \nIterator\n, and stores the results internally as a\n\nDOMDocument\n and \nDOMNodeList\n.\n\n\nAs an example, consider the following call, that selects against the HTML above:\n\n\nuse Zend\\Dom\\Query;\n\n$dom = new Query($html);\n$results = $dom-\nexecute('.foo .bar a');\n\n$count = count($results); // get number of matches: 4\nforeach ($results as $result) {\n    // $result is a DOMElement\n}\n\n\n\n\nZend\\Dom\\Query\n also allows straight XPath queries utilizing the \nqueryXpath()\n\nmethod; you can pass any valid XPath query to this method, and it will return a\n\nZend\\Dom\\NodeList\n object.\n\n\nMethods Available\n\n\nBelow is a listing of methods available in the various classes exposed by\nzend-dom.\n\n\nZend\\Dom\\Query\n\n\nThe following methods are available to \nZend\\Dom\\Query\n:\n\n\n\n\nsetDocumentXml($document, $encoding = null)\n: specify an XML string to query against.\n\n\nsetDocumentXhtml($document, $encoding = null)\n: specify an XHTML string to query against.\n\n\nsetDocumentHtml($document, $encoding = null)\n: specify an HTML string to query against.\n\n\nsetDocument($document, $encoding = null)\n: specify a string to query against;\n  \nZend\\Dom\\Query\n will then attempt to autodetect the document type.\n\n\nsetEncoding($encoding)\n: specify an encoding string to use. This encoding\n  will be passed to \nDOMDocument's constructor\n\n  if specified.\n\n\ngetDocument()\n: retrieve the original document string provided to the object.\n\n\ngetDocumentType()\n: retrieve the document type of the document provided to\n  the object; will be one of the \nDOC_XML\n, \nDOC_XHTML\n, or \nDOC_HTML\n class\n  constants.\n\n\ngetEncoding()\n: retrieves the specified encoding.\n\n\nexecute($query)\n: query the document using CSS selector notation.\n\n\nqueryXpath($xPathQuery)\n: query the document using XPath notation.\n\n\n\n\nZend\\Dom\\NodeList\n\n\nAs mentioned previously, \nZend\\Dom\\NodeList\n implements both \nIterator\n and\n\nCountable\n, and as such can be used in a \nforeach()\n loop as well as with the\n\ncount()\n function. Additionally, it exposes the following methods:\n\n\n\n\ngetCssQuery()\n: return the CSS selector query used to produce the result (if\n  any).\n\n\ngetXpathQuery()\n: return the XPath query used to produce the result.\n  Internally, \nZend\\Dom\\Query\n converts CSS selector queries to XPath, so this\n  value will always be populated.\n\n\ngetDocument()\n: retrieve the DOMDocument the selection was made against.", 
            "title": "Querying HTML and XML"
        }, 
        {
            "location": "/query/#querying-html-and-xml-documents", 
            "text": "Zend\\Dom\\Query  provides mechanisms for querying XML and HTML documents\nutilizing either XPath or CSS selectors. It was developed to aid with functional\ntesting of MVC applications, but could also be used for development of screen\nscrapers.  CSS selector notation is provided as a simpler and more familiar notation for\nweb developers to utilize when querying documents with XML structures. The\nnotation should be familiar to anybody who has developed Cascading Style Sheets\nor who utilizes javascript toolkits that provide functionality for selecting\nnodes utilizing CSS selectors.   Prototype's $$() , Dojo's dojo.query , and jQuery  were all inspirations for the component.", 
            "title": "Querying HTML and XML Documents"
        }, 
        {
            "location": "/query/#theory-of-operation", 
            "text": "To use  Zend\\Dom\\Query , you instantiate a  Zend\\Dom\\Query  object, optionally\npassing a document to query (a string). Once you have a document, you can use\neither the  execute()  or  queryXpath()  methods; each method will return a Zend\\Dom\\NodeList  object with any matching nodes.  The primary difference between  Zend\\Dom\\Query  and using DOMDocument  +  DOMXPath \nis the ability to select against CSS + selectors. You can utilize any of the\nfollowing, in any combination:   element types : provide an element type to match:  div ,  a ,  span ,  h2 , etc.  style attributes : CSS style attributes to match:  .error ,  div.error ,\n   label.required , etc. If an element defines more than one style, this will\n  match as long as the named style is present anywhere in the style declaration.  id attributes : element ID attributes to match:  #content ,  div#nav , etc.  arbitrary attributes : arbitrary element attributes to match. Three\n  different types of matching are provided:  exact match : the attribute  exactly  matches the specified string.\n   div[bar=\"baz\"]  would match a  div  element with a  bar  attribute that\n  exactly matches the value  baz .  word match : the attribute contains a  word  matching the string.\n   div[bar~=\"baz\"]  would match a  div  element with a  bar  attribute that\n  contains the word  baz .  div bar=\"foo baz\"  would match, but\n   div bar=\"foo bazbat\"  would not.  substring match : the attribute contains the string specified, whether or\n  not it is a complete word.  div[bar*=\"baz\"]  would match a  div  element\n  with a  bar  attribute that contains the string  baz  anywhere within it.    direct descendents : utilize   between selectors to denote direct\n  descendents.  div   span  would select only  span  elements that are direct\n  descendents of a  div . Can also be used with any of the selectors above.   descendents : string together multiple selectors to indicate a hierarchy along which to search.\n   div .foo span #one  would select an element of id  one  that is a descendent\n  of arbitrary depth beneath a  span  element, which is in turn a descendent of\n  arbitrary depth beneath an element with a class of  foo , that is an\n  descendent of arbitrary depth beneath a  div  element. For example, it would\n  match the link to the word 'One' in the listing below:  div  table \n     tr \n         td class= foo \n             div \n                Lorem ipsum  span class= bar \n                     a href= /foo/bar  id= one One /a \n                     a href= /foo/baz  id= two Two /a \n                     a href= /foo/bat  id= three Three /a \n                     a href= /foo/bla  id= four Four /a \n                 /span \n             /div \n         /td \n     /tr  /table  /div    Once you've performed your query, you can then work with the result object to\ndetermine information about the nodes, as well as to pull them and/or their\ncontent directly for examination and manipulation.  Zend\\Dom\\NodeList \nimplements  Countable  and  Iterator , and stores the results internally as a DOMDocument  and  DOMNodeList .  As an example, consider the following call, that selects against the HTML above:  use Zend\\Dom\\Query;\n\n$dom = new Query($html);\n$results = $dom- execute('.foo .bar a');\n\n$count = count($results); // get number of matches: 4\nforeach ($results as $result) {\n    // $result is a DOMElement\n}  Zend\\Dom\\Query  also allows straight XPath queries utilizing the  queryXpath() \nmethod; you can pass any valid XPath query to this method, and it will return a Zend\\Dom\\NodeList  object.", 
            "title": "Theory of Operation"
        }, 
        {
            "location": "/query/#methods-available", 
            "text": "Below is a listing of methods available in the various classes exposed by\nzend-dom.", 
            "title": "Methods Available"
        }, 
        {
            "location": "/query/#zend92dom92query", 
            "text": "The following methods are available to  Zend\\Dom\\Query :   setDocumentXml($document, $encoding = null) : specify an XML string to query against.  setDocumentXhtml($document, $encoding = null) : specify an XHTML string to query against.  setDocumentHtml($document, $encoding = null) : specify an HTML string to query against.  setDocument($document, $encoding = null) : specify a string to query against;\n   Zend\\Dom\\Query  will then attempt to autodetect the document type.  setEncoding($encoding) : specify an encoding string to use. This encoding\n  will be passed to  DOMDocument's constructor \n  if specified.  getDocument() : retrieve the original document string provided to the object.  getDocumentType() : retrieve the document type of the document provided to\n  the object; will be one of the  DOC_XML ,  DOC_XHTML , or  DOC_HTML  class\n  constants.  getEncoding() : retrieves the specified encoding.  execute($query) : query the document using CSS selector notation.  queryXpath($xPathQuery) : query the document using XPath notation.", 
            "title": "Zend\\Dom\\Query"
        }, 
        {
            "location": "/query/#zend92dom92nodelist", 
            "text": "As mentioned previously,  Zend\\Dom\\NodeList  implements both  Iterator  and Countable , and as such can be used in a  foreach()  loop as well as with the count()  function. Additionally, it exposes the following methods:   getCssQuery() : return the CSS selector query used to produce the result (if\n  any).  getXpathQuery() : return the XPath query used to produce the result.\n  Internally,  Zend\\Dom\\Query  converts CSS selector queries to XPath, so this\n  value will always be populated.  getDocument() : retrieve the DOMDocument the selection was made against.", 
            "title": "Zend\\Dom\\NodeList"
        }
    ]
}